import { Container, Typography } from '@mui/material';
import { useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { connect } from 'react-redux';
import { decode, decodeImage } from 'utif';
import { addOrder, clearOrders } from '../../../redux/modules/orders';
import SaveAltIcon from '@mui/icons-material/SaveAlt';

const MM_PER_PIXEL = 0.0846526655896607;
const MM_PER_POINT = 0.3527777777778; // 1pt = 25,4/72mm

/**
 * This Component renders a Field, in which files can be dropped
 */

const Dropzone = (props) => {
  const { images, add, clear } = props;

  /**
   * Calculates the Dimension of the Images and saves it in the Images state
   * @param  {Array} Images Array of Images Objects with {name, file, width, height}
   * @param  {file} file    Files from the dropped callback
   * @return {Promise}      Resolves to an Image Object
   * Pseudocode
   * 1. image?
   *   1.1 true - TIFF?
   *    1.1.1 true -> Tiffdecoder
   *      1.1.2 catch if TIFF generated by Corel = not supported
   *    1.1.3 false -> load Image and get dimension
   *
   *   1.2 false - EPS?
   *     1.2.1 true -> Open File and calculate dimension
   *     1.2.2 TODO:Other - return Error Message
   */
  const getDimension = async (Images, file) => {
    //1.1
    if (file.type.includes('image')) {
      return new Promise((resolve) => {
        if (file.type.includes('tif')) {
          var reader = new FileReader();
          reader.onload = (event) => {
            try {
              let ifd = decode(event.target.result)[0];
              decodeImage(event.target.result, ifd);

              resolve({
                name: file.name,
                file: file,
                width: ifd.width * MM_PER_PIXEL,
                height: ifd.height * MM_PER_PIXEL
              });
            } catch (error) {
              console.log(error);
            }
          };
          reader.readAsArrayBuffer(file);
        } else {
          //1.1.3

          var img = new Image();
          img.onload = (e) => {
            resolve({
              name: file.name,
              file: file,
              width: img.width,
              height: img.height
            });
          };
          img.src = URL.createObjectURL(file);
        }
      });
    } else {
      //1.2
      return new Promise((resolve, reject) => {
        var reader = new FileReader();
        reader.onload = (e) => {
          var match = e.target.result.match(/@rax %Note: Object((.*\r\n){2})/g);
          if (match) {
            let numbers = match[0].match(/[-?\d.]+/g);
            let minX = parseFloat(numbers[0]);
            let minY = parseFloat(numbers[1]);
            let maxX = parseFloat(numbers[2]);
            let maxY = parseFloat(numbers[3]);
            let tmp;

            match.forEach((m) => {
              let numbers = m.match(/[-?\d.]+/g);
              tmp = parseFloat(numbers[0]);
              if (tmp < minX) minX = tmp;

              tmp = parseFloat(numbers[1]);
              if (tmp < minY) minY = tmp;

              tmp = parseFloat(numbers[2]);
              if (tmp > maxX) maxX = tmp;

              tmp = parseFloat(numbers[3]);
              if (tmp > maxY) maxY = tmp;
            });

            let width = Math.abs(minX - maxX) * MM_PER_POINT;
            let height = Math.abs(minY - maxY) * MM_PER_POINT;

            resolve({
              name: file.name,
              file: file,
              width: Math.round(width * 100) / 100,
              height: Math.round(height * 100) / 100
            });
          } else {
            console.log('Sorry, nicht bekannter Filetyp: ', file.name);
            reject();
          }
        };
        reader.readAsText(file);
      });
    }
  };

  /**
   * This Callback will be used when files are orders in to the field
   * @type {Callback}
   */

  const onDrop = useCallback(
    (acceptedFiles) => {
      let promises = acceptedFiles.map(async (file) => {
        return getDimension(images, file);
      });
      let resolvedPromises = Promise.all(
        promises.map((p) => p.catch((e) => 'FAILED'))
      ).then((values) => values.filter((v) => v !== 'FAILED'));

      resolvedPromises.then((returnedValues) =>
        returnedValues.forEach((value) => add(value))
      );
    },
    [images, add]
  );

  const { getRootProps, getInputProps, isDragActive } = useDropzone({ onDrop });
  return (
    <Container maxWidth="sm">
      <div
        {...getRootProps()}
        style={{
          display: 'grid',
          alignItems: 'center',
          backgroundColor: '#cfe8fc',
          height: '300px'
        }}
      >
        <input
          {...getInputProps({
            //Its important to filter, because somehow .cdrt files makes the HTML5 Filepicker to crash
            //Add more filters if any forgotten
            accept: 'image/*, .eps'
          })}
        />
        {isDragActive ? (
          <div>
            <Typography variant="h1">Datei hier reinziehen ...</Typography>
          </div>
        ) : (
          <div>
            <Typography variant="h5">
              <center>
                Datei hier reinziehen,
                <br /> oder f√ºr die Dateiauswahl klicken
              </center>
              <center>
                <SaveAltIcon style={{ fontSize: '2.5em' }} />
              </center>
            </Typography>
          </div>
        )}
      </div>
      <div></div>
    </Container>
  );
};

const mapStatetoProps = (state) => ({
  images: state.orderStore.orders
});

const mapDispatchToProps = (dispatch) => {
  return {
    add: (order) => dispatch(addOrder(order))
  };
};

export default connect(mapStatetoProps, mapDispatchToProps)(Dropzone);
